Joining data is an essential skill which enables us to draw information from separate tables together into a single, meaningful set of results.

## Defining relationships
- One-to-many relationship. Â This is the most common type of relationship, one where a single entity can be associated with several entities. Think about a music library. One artist can produce many songs over their career. This is a one-to-many relationship. In the table schema shown, each of her works are stored in the books table, and can be merged with the authors table using author_id from both tables.
![](20250119213302.png)

- One-to-one relationships imply unique pairings between entities and are therefore less common. A commonly held premise of forensic science is that no two fingerprints are identical, and therefore that a particular fingerprint can only be generated by one person. This is an example of a one-to-one relationship: one fingerprint for one finger. `Note here that although an individual will have four fingerprints stored in the fingerprints table, this is not a one-to-many relationship. It is a one-to-one relationship, because a single individual - represented as one record on the individuals table - will have one set of fingerprints - represented as one record on the fingerprints table. The four different fingerprints are four different fields in each record.`
![](20250119213755.png)

- Many-to-many relationships. An example of this is languages and countries. Here we show the official languages of Germany, Belgium and the Netherlands, where we see that many languages can be spoken in many countries.
![](20250119215236.png)


## INNER JOIN

![](20250119210610.png)
![](20250119210842.png)

Suppose that we're interested in countries that have both a president and prime minister. In these small tables, we might notice that Egypt, Portugal, Pakistan and India appear in both tables. For larger tables though, it's not as feasible to identify these records by visual inspection. Here's where SQL joins can be helpful.

![](20250119211312.png)

It is common to begin constructing the query with the join first, and selecting fields later. After FROM, we list the left table, followed by the INNER JOIN keyword and the right table. We then specify the field to match the tables on, using the ON keyword. Here, we use the "country" field. Lastly, we add SELECT at the start of the query and choose the fields we want returned. 
`When selecting columns that exist in both tables, such as "country" and "continent", the table-dot-column_name format must be used to avoid a SQL error.`
![](20250119211425.png)

In our INNER JOIN, we've had to type out "president" and "prime_minister" several times. Luckily, we can alias table names using the same AS keyword used to alias column names. Here, we use aliases p1 and p2 in both our SELECT and ON clauses to shorten our query.
![](20250119211744.png)

When joining on two identical column names, we can employ the USING command followed by the shared column name in parentheses. Here, since the join field is named "country" in both tables, we can use USING.
![](20250119211847.png)


## Multiple joins

A powerful feature of SQL is that multiple joins can be combined and run in a single query.
We begin with the same INNER JOIN as before, and then chain another INNER JOIN to the result of our first INNER JOIN. 

We can continue the chain and join as many tables together as we need!
![](20250119220723.png)

We can limit the records returned by supplying an additional field to join on by adding the AND keyword to our ON clause. In this example, we join on date, a frequently used second column when joining on multiple fields. The result set now contains records that match on both id AND date.
![](20250119220928.png)

## LEFT and RIGHT joins
Outer joins can obtain records from other tables, even if matches are not found for the field being joined on.
### LEFT JOIN
 Will return all records in the left_table, and those records in the right_table that match on the joining field provided.  Whereas LEFT JOIN keeps all records in left_table, as well as null values for right_val where is no match in right_table. Note that ids 5 and 6 in right_table do not feature in LEFT JOIN in any way.

![](20250119232159.png)

Say we want our query to include all countries with prime ministers, presidents if they happen to have them, and missing values if they don't. The first three records in the result are the same as they were with an INNER JOIN, but from the fourth record the result starts to look different. Since the United Kingdom does not have a president, a corresponding null value is returned in the president field.

![](20250119232446.png)

### RIGHT JOIN
RIGHT JOIN is the second type of outer join, and is much less common than LEFT JOIN. 
Instead of matching entries in the id column of the left table to the id column of the right table, a RIGHT JOIN does the reverse. All records are retained from right_table, even when id doesn't find a corresponding match in left_table. Null values are returned for the left_value field in records that do not find a match.

![](20250119232709.png)

We perform a right join of prime_ministers on the left and presidents on the right. The only change is from the LEFT JOIN keyword to RIGHT JOIN. The result contains null values where countries have presidents but no prime ministers.

![](20250119232812.png)

### FULL JOIN
A FULL JOIN combines a LEFT JOIN and a RIGHT JOIN. As you can see in this diagram, no values are faded out as they were in earlier diagrams. This is because the FULL JOIN will return all ids, irrespective of whether they have a match in the other table being joined.
`Note that this time, nulls can appear in either left_value or right_value fields.`

![](20250120003107.png)

Suppose we were interested in all the countries in our database, and wanted to check whether they had a president, a prime minister, or both. We'll walk through the code line by line to do this using a FULL JOIN.
`Note that order of the tables matters here, and if we switched the order, the records would be ordered differently depending on how prime ministers and presidents are ordered in the tables.`
We chose a FULL JOIN because we were interested in all countries, whether they had a prime minister, a president, or both.

![](20250120003825.png)
![](20250120003844.png)

### CROSS JOIN
CROSS JOINs are slightly different than joins we have seen previously: they create all possible combinations of two tables.
In this diagram we have two tables named table1 and table2, with one field each: id1 and id2, respectively. The result of the CROSS JOIN is all nine combinations of the id values of 1, 2, and 3 in table1 with the id values of A, B, and C for table2.

![](20250120005034.png)

Suppose that all prime ministers in Asia from our database are scheduled for individual meetings with all presidents in South America from our database, and we are journalists who wish to follow all the meetings that will happen.
We use a WHERE clause to focus only on prime ministers from Asia and presidents from South America. The results of the query give us all possible pairings of the four prime ministers from Asia in the prime_ministers table, and the two presidents from South America in the presidents table.
`Note that the syntax is very minimal, and we do not specify ON or USING with CROSS JOIN.`

![](20250120005414.png)

### SELF JOIN
Joining a table to itself may seem like an unusual thing to do. Why would we want to do that? Self joins are used to compare values from part of a table to other values from within the same table.

We can't just write SELF JOIN in SQL code, for example. In addition, aliasing is required for a self join.
Let's look at a chunk of INNER JOIN code using the prime_ministers table. The country column is selected twice, and so is the continent column. The prime_ministers table is on both the left and the right of the JOIN, making this both a self join and an INNER JOIN!
The vital step here is setting the joining fields which we use to match the table to itself. For each country, we will find multiple matched countries in the right table, since we are joining on continent. Each of these matched countries will be returned as pairs. Since this query will return several records, we use LIMIT to return only the first 10 records.

![](20250120011026.png)

The results are a pairing of each country with every other country in the same continent. However, note that our join also paired countries with themselves, since they too are in the same continent as themselves.

![](20250120011141.png)

To fix this, recall the use of the AND clause to ensure multiple conditions are met in the ON clause. In our second condition, we use the not equal to operator (`<>`, `NOT EQUAL` or `!=`) to exclude records where the p1-dot-country and p2-dot-country fields ar
![](20250120011404.png)
![](20250120011651.png)
